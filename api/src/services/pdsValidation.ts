import { PDSData, PDSValidationError, PDSValidationResult } from '@/models/pds';\nimport { format, isValid, parse } from 'date-fns';\n\nexport class PDSValidationService {\n  /**\n   * Validates complete PDS data according to CSC requirements\n   */\n  public static validatePDS(pdsData: PDSData): PDSValidationResult {\n    const errors: PDSValidationError[] = [];\n    const warnings: PDSValidationError[] = [];\n\n    // Validate personal information\n    errors.push(...this.validatePersonalInformation(pdsData.personalInformation));\n    \n    // Validate family background\n    errors.push(...this.validateFamilyBackground(pdsData.familyBackground));\n    \n    // Validate educational background\n    errors.push(...this.validateEducationalBackground(pdsData.educationalBackground));\n    \n    // Validate civil service eligibility\n    errors.push(...this.validateCivilServiceEligibility(pdsData.civilServiceEligibility));\n    \n    // Validate work experience\n    errors.push(...this.validateWorkExperience(pdsData.workExperience));\n    \n    // Validate voluntary work\n    errors.push(...this.validateVoluntaryWork(pdsData.voluntaryWork));\n    \n    // Validate learning and development\n    errors.push(...this.validateLearningDevelopment(pdsData.learningAndDevelopment));\n    \n    // Validate other information\n    errors.push(...this.validateOtherInformation(pdsData.otherInformation));\n    \n    // Validate questions and answers\n    errors.push(...this.validateQuestionsAnswers(pdsData.questionsAnswers));\n    \n    // Validate references\n    errors.push(...this.validateReferences(pdsData.references));\n    \n    // Validate signature and authentication\n    errors.push(...this.validateSignatureAndAuth(pdsData));\n\n    return {\n      isValid: errors.length === 0,\n      errors,\n      warnings\n    };\n  }\n\n  /**\n   * Validates personal information section\n   */\n  private static validatePersonalInformation(personalInfo: PDSData['personalInformation']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    // Validate name format: surname, first name, name extension (if any), middle name\n    if (!personalInfo.surname || personalInfo.surname.trim() === '') {\n      errors.push({\n        field: 'personalInformation.surname',\n        message: 'Surname is required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    if (!personalInfo.firstName || personalInfo.firstName.trim() === '') {\n      errors.push({\n        field: 'personalInformation.firstName',\n        message: 'First name is required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    if (!personalInfo.middleName || personalInfo.middleName.trim() === '') {\n      errors.push({\n        field: 'personalInformation.middleName',\n        message: 'Middle name is required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    // Validate date format: mm/dd/yyyy\n    if (!this.validateDateFormat(personalInfo.dateOfBirth)) {\n      errors.push({\n        field: 'personalInformation.dateOfBirth',\n        message: 'Date of birth must be in MM/DD/YYYY format',\n        code: 'INVALID_DATE_FORMAT',\n        severity: 'error',\n        suggestion: 'Use MM/DD/YYYY format (e.g., 12/31/1990)'\n      });\n    }\n\n    // Validate civil status\n    const validCivilStatuses = ['Single', 'Married', 'Widowed', 'Separated', 'Others'];\n    if (!validCivilStatuses.includes(personalInfo.civilStatus)) {\n      errors.push({\n        field: 'personalInformation.civilStatus',\n        message: 'Invalid civil status',\n        code: 'INVALID_CIVIL_STATUS',\n        severity: 'error',\n        suggestion: 'Must be one of: Single, Married, Widowed, Separated, Others'\n      });\n    }\n\n    // If civil status is \"Others\", details should be provided\n    if (personalInfo.civilStatus === 'Others' && !personalInfo.civilStatusDetails) {\n      errors.push({\n        field: 'personalInformation.civilStatusDetails',\n        message: 'Civil status details required when status is \"Others\"',\n        code: 'REQUIRED_DETAILS',\n        severity: 'error'\n      });\n    }\n\n    // Validate address fields\n    errors.push(...this.validateAddress(personalInfo.residentialAddress, 'personalInformation.residentialAddress'));\n    errors.push(...this.validateAddress(personalInfo.permanentAddress, 'personalInformation.permanentAddress'));\n\n    // Validate email format if provided\n    if (personalInfo.emailAddress && !this.validateEmailFormat(personalInfo.emailAddress)) {\n      errors.push({\n        field: 'personalInformation.emailAddress',\n        message: 'Invalid email format',\n        code: 'INVALID_EMAIL_FORMAT',\n        severity: 'error'\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validates family background section\n   */\n  private static validateFamilyBackground(familyBackground: PDSData['familyBackground']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    // Validate father's name format\n    if (!familyBackground.father.surname || !familyBackground.father.firstName) {\n      errors.push({\n        field: 'familyBackground.father',\n        message: 'Father\\'s surname and first name are required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    // Validate mother's name format (maiden name required)\n    if (!familyBackground.mother.maidenName || !familyBackground.mother.firstName) {\n      errors.push({\n        field: 'familyBackground.mother',\n        message: 'Mother\\'s maiden name and first name are required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    // Validate children's information\n    familyBackground.children.forEach((child, index) => {\n      if (!child.fullName || child.fullName.trim() === '') {\n        errors.push({\n          field: `familyBackground.children[${index}].fullName`,\n          message: 'Child\\'s full name (first name and surname) is required',\n          code: 'REQUIRED_FIELD',\n          severity: 'error'\n        });\n      }\n\n      if (!this.validateDateFormat(child.dateOfBirth)) {\n        errors.push({\n          field: `familyBackground.children[${index}].dateOfBirth`,\n          message: 'Child\\'s date of birth must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates educational background section\n   */\n  private static validateEducationalBackground(educationalBackground: PDSData['educationalBackground']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    // Validate elementary level\n    if (educationalBackground.elementary.nameOfSchool && \n        !educationalBackground.elementary.nameOfSchool.includes('ELEMENTARY')) {\n      errors.push({\n        field: 'educationalBackground.elementary.basicEducationDegreeCourse',\n        message: 'Elementary level should indicate \"ELEMENTARY\" if graduated',\n        code: 'INVALID_EDUCATION_LEVEL',\n        severity: 'error',\n        suggestion: 'Use \"ELEMENTARY\" for elementary level'\n      });\n    }\n\n    // Validate secondary level\n    if (educationalBackground.secondary.nameOfSchool) {\n      const validSecondaryLevels = ['HIGH SCHOOL', 'JUNIOR HIGH SCHOOL', 'SENIOR HIGH SCHOOL'];\n      if (!validSecondaryLevels.some(level => \n        educationalBackground.secondary.basicEducationDegreeCourse.includes(level))) {\n        errors.push({\n          field: 'educationalBackground.secondary.basicEducationDegreeCourse',\n          message: 'Secondary level should indicate HIGH SCHOOL, JUNIOR HIGH SCHOOL, or SENIOR HIGH SCHOOL',\n          code: 'INVALID_EDUCATION_LEVEL',\n          severity: 'error'\n        });\n      }\n    }\n\n    // Validate school name format (FULL name, DO NOT ABBREVIATE)\n    [educationalBackground.elementary, educationalBackground.secondary, \n     educationalBackground.vocational, educationalBackground.college].forEach((level, index) => {\n      if (level && level.nameOfSchool && this.containsAbbreviation(level.nameOfSchool)) {\n        const levelNames = ['elementary', 'secondary', 'vocational', 'college'];\n        errors.push({\n          field: `educationalBackground.${levelNames[index]}.nameOfSchool`,\n          message: 'School name should be in FULL form, do not abbreviate',\n          code: 'ABBREVIATION_NOT_ALLOWED',\n          severity: 'error',\n          suggestion: 'Write the complete school name without abbreviations'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates civil service eligibility section\n   */\n  private static validateCivilServiceEligibility(eligibilities: PDSData['civilServiceEligibility']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    eligibilities.forEach((eligibility, index) => {\n      // Validate date format\n      if (!this.validateDateFormat(eligibility.dateOfExaminationConferment)) {\n        errors.push({\n          field: `civilServiceEligibility[${index}].dateOfExaminationConferment`,\n          message: 'Date of examination/conferment must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      // Validate license validity date if license number is provided\n      if (eligibility.licenseNumber && !eligibility.licenseValidityDate) {\n        errors.push({\n          field: `civilServiceEligibility[${index}].licenseValidityDate`,\n          message: 'License validity date is required when license number is provided',\n          code: 'REQUIRED_FIELD',\n          severity: 'error'\n        });\n      }\n\n      if (eligibility.licenseValidityDate && !this.validateDateFormat(eligibility.licenseValidityDate)) {\n        errors.push({\n          field: `civilServiceEligibility[${index}].licenseValidityDate`,\n          message: 'License validity date must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates work experience section\n   */\n  private static validateWorkExperience(workExperiences: PDSData['workExperience']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    workExperiences.forEach((experience, index) => {\n      // Validate inclusive dates format\n      if (!this.validateDateFormat(experience.inclusiveDates.from)) {\n        errors.push({\n          field: `workExperience[${index}].inclusiveDates.from`,\n          message: 'Start date must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      if (experience.inclusiveDates.to !== 'Present' && !this.validateDateFormat(experience.inclusiveDates.to)) {\n        errors.push({\n          field: `workExperience[${index}].inclusiveDates.to`,\n          message: 'End date must be in MM/DD/YYYY format or \"Present\"',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      // Validate position title and department (FULL names, DO NOT ABBREVIATE)\n      if (this.containsAbbreviation(experience.positionTitle)) {\n        errors.push({\n          field: `workExperience[${index}].positionTitle`,\n          message: 'Position title should be in FULL form, do not abbreviate',\n          code: 'ABBREVIATION_NOT_ALLOWED',\n          severity: 'error'\n        });\n      }\n\n      if (this.containsAbbreviation(experience.departmentAgencyOfficeCompany)) {\n        errors.push({\n          field: `workExperience[${index}].departmentAgencyOfficeCompany`,\n          message: 'Department/agency/office/company name should be in FULL form, do not abbreviate',\n          code: 'ABBREVIATION_NOT_ALLOWED',\n          severity: 'error'\n        });\n      }\n\n      // Validate salary format\n      if (experience.monthlySalary <= 0) {\n        errors.push({\n          field: `workExperience[${index}].monthlySalary`,\n          message: 'Monthly salary must be a positive number',\n          code: 'INVALID_SALARY',\n          severity: 'error'\n        });\n      }\n\n      // Validate salary grade format (00-0)\n      if (experience.salaryGrade && !/^\\d{2}-\\d$/.test(experience.salaryGrade)) {\n        errors.push({\n          field: `workExperience[${index}].salaryGrade`,\n          message: 'Salary grade should be in format \"00-0\" (e.g., \"24-2\")',\n          code: 'INVALID_SALARY_GRADE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      // Validate status of appointment\n      const validStatuses = ['Permanent', 'Temporary', 'Casual', 'Contractual'];\n      if (!validStatuses.includes(experience.statusOfAppointment)) {\n        errors.push({\n          field: `workExperience[${index}].statusOfAppointment`,\n          message: 'Status of appointment must be one of: Permanent, Temporary, Casual, Contractual',\n          code: 'INVALID_APPOINTMENT_STATUS',\n          severity: 'error'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates voluntary work section\n   */\n  private static validateVoluntaryWork(voluntaryWorks: PDSData['voluntaryWork']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    voluntaryWorks.forEach((work, index) => {\n      // Validate inclusive dates format\n      if (!this.validateDateFormat(work.inclusiveDates.from)) {\n        errors.push({\n          field: `voluntaryWork[${index}].inclusiveDates.from`,\n          message: 'Start date must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      if (!this.validateDateFormat(work.inclusiveDates.to)) {\n        errors.push({\n          field: `voluntaryWork[${index}].inclusiveDates.to`,\n          message: 'End date must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      // Validate number of hours\n      if (work.numberOfHours <= 0) {\n        errors.push({\n          field: `voluntaryWork[${index}].numberOfHours`,\n          message: 'Number of hours must be a positive number',\n          code: 'INVALID_HOURS',\n          severity: 'error'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates learning and development section\n   */\n  private static validateLearningDevelopment(learningDevelopments: PDSData['learningAndDevelopment']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    learningDevelopments.forEach((ld, index) => {\n      // Validate inclusive dates format\n      if (!this.validateDateFormat(ld.inclusiveDates.from)) {\n        errors.push({\n          field: `learningAndDevelopment[${index}].inclusiveDates.from`,\n          message: 'Start date must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      if (!this.validateDateFormat(ld.inclusiveDates.to)) {\n        errors.push({\n          field: `learningAndDevelopment[${index}].inclusiveDates.to`,\n          message: 'End date must be in MM/DD/YYYY format',\n          code: 'INVALID_DATE_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      // Validate L&D type\n      const validTypes = ['Managerial', 'Supervisory', 'Technical', 'Foundation'];\n      if (!validTypes.includes(ld.type)) {\n        errors.push({\n          field: `learningAndDevelopment[${index}].type`,\n          message: 'L&D type must be one of: Managerial, Supervisory, Technical, Foundation',\n          code: 'INVALID_LD_TYPE',\n          severity: 'error'\n        });\n      }\n\n      // Validate conducted/sponsored by (FULL name, DO NOT ABBREVIATE)\n      if (this.containsAbbreviation(ld.conductedSponsoredBy)) {\n        errors.push({\n          field: `learningAndDevelopment[${index}].conductedSponsoredBy`,\n          message: 'Institution/agency name should be in FULL form, do not abbreviate',\n          code: 'ABBREVIATION_NOT_ALLOWED',\n          severity: 'error',\n          suggestion: 'e.g., use \"Civil Service Commission\" instead of \"CSC\"'\n        });\n      }\n\n      // Validate number of hours\n      if (ld.numberOfHours <= 0) {\n        errors.push({\n          field: `learningAndDevelopment[${index}].numberOfHours`,\n          message: 'Number of hours must be a positive number',\n          code: 'INVALID_HOURS',\n          severity: 'error'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates other information section\n   */\n  private static validateOtherInformation(otherInfo: PDSData['otherInformation']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    // Check if arrays are empty (should use \"N/A\" if not applicable)\n    if (otherInfo.specialSkillsHobbies.length === 0) {\n      errors.push({\n        field: 'otherInformation.specialSkillsHobbies',\n        message: 'Special skills/hobbies field cannot be empty. Use \"N/A\" if not applicable.',\n        code: 'EMPTY_FIELD',\n        severity: 'error'\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Validates questions and answers section\n   */\n  private static validateQuestionsAnswers(questionsAnswers: PDSData['questionsAnswers']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    // Validate that all questions have answers\n    const questions = ['question34', 'question35', 'question36', 'question37', 'question38', 'question39', 'question40'];\n    \n    questions.forEach(question => {\n      const answer = questionsAnswers[question as keyof PDSData['questionsAnswers']];\n      if (answer === undefined || answer.answer === undefined) {\n        errors.push({\n          field: `questionsAnswers.${question}`,\n          message: 'All questions must be answered',\n          code: 'REQUIRED_FIELD',\n          severity: 'error'\n        });\n      }\n\n      // If answer is \"yes\", details should be provided\n      if (answer && answer.answer === true && !answer.details) {\n        errors.push({\n          field: `questionsAnswers.${question}.details`,\n          message: 'Details are required when answer is \"Yes\"',\n          code: 'REQUIRED_DETAILS',\n          severity: 'error'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates references section\n   */\n  private static validateReferences(references: PDSData['references']): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    references.forEach((reference, index) => {\n      // Validate name format: FIRST NAME, MI, SURNAME\n      if (!this.validateReferenceNameFormat(reference.name)) {\n        errors.push({\n          field: `references[${index}].name`,\n          message: 'Reference name should be in format: FIRST NAME, MI, SURNAME',\n          code: 'INVALID_NAME_FORMAT',\n          severity: 'error'\n        });\n      }\n\n      // Validate required fields\n      if (!reference.address || reference.address.trim() === '') {\n        errors.push({\n          field: `references[${index}].address`,\n          message: 'Reference address is required',\n          code: 'REQUIRED_FIELD',\n          severity: 'error'\n        });\n      }\n\n      if (!reference.telephoneNumber || reference.telephoneNumber.trim() === '') {\n        errors.push({\n          field: `references[${index}].telephoneNumber`,\n          message: 'Reference telephone number is required',\n          code: 'REQUIRED_FIELD',\n          severity: 'error'\n        });\n      }\n    });\n\n    return errors;\n  }\n\n  /**\n   * Validates signature and authentication section\n   */\n  private static validateSignatureAndAuth(pdsData: PDSData): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n\n    // Validate required signature and authentication fields\n    if (!pdsData.signature || pdsData.signature.trim() === '') {\n      errors.push({\n        field: 'signature',\n        message: 'Employee signature is required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    if (!pdsData.rightThumbMark || pdsData.rightThumbMark.trim() === '') {\n      errors.push({\n        field: 'rightThumbMark',\n        message: 'Right thumb mark is required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    if (!pdsData.governmentIdNumber || pdsData.governmentIdNumber.trim() === '') {\n      errors.push({\n        field: 'governmentIdNumber',\n        message: 'Government ID number is required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    if (!this.validateDateFormat(pdsData.governmentIdIssuanceDate)) {\n      errors.push({\n        field: 'governmentIdIssuanceDate',\n        message: 'Government ID issuance date must be in MM/DD/YYYY format',\n        code: 'INVALID_DATE_FORMAT',\n        severity: 'error'\n      });\n    }\n\n    if (!this.validateDateFormat(pdsData.dateAccomplished)) {\n      errors.push({\n        field: 'dateAccomplished',\n        message: 'Date accomplished must be in MM/DD/YYYY format',\n        code: 'INVALID_DATE_FORMAT',\n        severity: 'error'\n      });\n    }\n\n    // Validate passport size photo (4.5 cm x 3.5 cm)\n    if (!pdsData.passportSizePhoto || pdsData.passportSizePhoto.trim() === '') {\n      errors.push({\n        field: 'passportSizePhoto',\n        message: 'Passport size photo (4.5 cm x 3.5 cm) is required',\n        code: 'REQUIRED_FIELD',\n        severity: 'error'\n      });\n    }\n\n    return errors;\n  }\n\n  /**\n   * Helper method to validate date format (MM/DD/YYYY)\n   */\n  private static validateDateFormat(dateString: string): boolean {\n    if (!dateString) return false;\n    \n    // Check if format matches MM/DD/YYYY\n    const dateRegex = /^(0[1-9]|1[0-2])\\/(0[1-9]|[12]\\d|3[01])\\/(19|20)\\d{2}$/;\n    if (!dateRegex.test(dateString)) return false;\n    \n    // Check if date is valid\n    const parsedDate = parse(dateString, 'MM/dd/yyyy', new Date());\n    return isValid(parsedDate);\n  }\n\n  /**\n   * Helper method to validate email format\n   */\n  private static validateEmailFormat(email: string): boolean {\n    const emailRegex = /^[^\\s@]+@[^\\s@]+\\.[^\\s@]+$/;\n    return emailRegex.test(email);\n  }\n\n  /**\n   * Helper method to validate address fields\n   */\n  private static validateAddress(address: PDSData['personalInformation']['residentialAddress'], fieldPrefix: string): PDSValidationError[] {\n    const errors: PDSValidationError[] = [];\n    \n    const requiredFields = ['barangay', 'cityMunicipality', 'province', 'zipCode'];\n    \n    requiredFields.forEach(field => {\n      if (!address[field as keyof typeof address] || address[field as keyof typeof address].trim() === '') {\n        errors.push({\n          field: `${fieldPrefix}.${field}`,\n          message: `${field} is required`,\n          code: 'REQUIRED_FIELD',\n          severity: 'error'\n        });\n      }\n    });\n    \n    return errors;\n  }\n\n  /**\n   * Helper method to check if text contains abbreviations\n   */\n  private static containsAbbreviation(text: string): boolean {\n    // Common abbreviations to check for\n    const commonAbbreviations = [\n      'CSC', 'DILG', 'DOH', 'DepEd', 'DOST', 'DBM', 'DSWD',\n      'Univ', 'College', 'Inst', 'Dept', 'Gov', 'Nat\\'l', 'Reg\\'l',\n      'Phil', 'Inc', 'Corp', 'Co', 'Ltd', 'LLC'\n    ];\n    \n    return commonAbbreviations.some(abbrev => \n      text.toUpperCase().includes(abbrev.toUpperCase())\n    );\n  }\n\n  /**\n   * Helper method to validate reference name format\n   */\n  private static validateReferenceNameFormat(name: string): boolean {\n    // Should be in format: FIRST NAME, MI, SURNAME\n    const nameRegex = /^[A-Z\\s]+,\\s*[A-Z]\\.?,\\s*[A-Z\\s]+$/;\n    return nameRegex.test(name);\n  }\n\n  /**\n   * Validates a specific field\n   */\n  public static validateField(fieldPath: string, value: any): {\n    isValid: boolean;\n    errors: PDSValidationError[];\n    suggestions: string[];\n  } {\n    const errors: PDSValidationError[] = [];\n    const suggestions: string[] = [];\n\n    try {\n      // Extract field name from path\n      const fieldName = fieldPath.split('.').pop() || fieldPath;\n\n      // Date fields\n      if (fieldName.toLowerCase().includes('date') || fieldName === 'dateOfBirth' || fieldName === 'dateAccomplished') {\n        if (!this.validateDateFormat(value)) {\n          errors.push({\n            field: fieldPath,\n            message: 'Date must be in MM/DD/YYYY format',\n            code: 'INVALID_DATE_FORMAT',\n            severity: 'error',\n            suggestion: 'Use MM/DD/YYYY format (e.g., 12/31/1990)'\n          });\n          suggestions.push('Use MM/DD/YYYY format (e.g., 12/31/1990)');\n        }\n      }\n\n      // Email fields\n      if (fieldName.toLowerCase().includes('email')) {\n        if (value && !this.validateEmailFormat(value)) {\n          errors.push({\n            field: fieldPath,\n            message: 'Invalid email format',\n            code: 'INVALID_EMAIL_FORMAT',\n            severity: 'error'\n          });\n          suggestions.push('Use valid email format (e.g., user@domain.com)');\n        }\n      }\n\n      // Name fields\n      if (['surname', 'firstName', 'middleName'].includes(fieldName)) {\n        if (!value || value.trim() === '') {\n          errors.push({\n            field: fieldPath,\n            message: `${fieldName} is required`,\n            code: 'REQUIRED_FIELD',\n            severity: 'error'\n          });\n          suggestions.push(`${fieldName} cannot be empty`);\n        }\n      }\n\n      // Civil status\n      if (fieldName === 'civilStatus') {\n        const validStatuses = ['Single', 'Married', 'Widowed', 'Separated', 'Others'];\n        if (!validStatuses.includes(value)) {\n          errors.push({\n            field: fieldPath,\n            message: 'Invalid civil status',\n            code: 'INVALID_CIVIL_STATUS',\n            severity: 'error'\n          });\n          suggestions.push('Must be one of: Single, Married, Widowed, Separated, Others');\n        }\n      }\n\n      // School/institution names (check for abbreviations)\n      if (fieldName === 'nameOfSchool' || fieldName === 'conductedSponsoredBy' || \n          fieldName === 'departmentAgencyOfficeCompany') {\n        if (value && this.containsAbbreviation(value)) {\n          errors.push({\n            field: fieldPath,\n            message: 'Should not contain abbreviations',\n            code: 'ABBREVIATION_NOT_ALLOWED',\n            severity: 'error',\n            suggestion: 'Use full names without abbreviations'\n          });\n          suggestions.push('Use full names without abbreviations');\n        }\n      }\n\n      return {\n        isValid: errors.length === 0,\n        errors,\n        suggestions\n      };\n    } catch (error) {\n      return {\n        isValid: false,\n        errors: [{\n          field: fieldPath,\n          message: 'Field validation failed',\n          code: 'VALIDATION_ERROR',\n          severity: 'error'\n        }],\n        suggestions: []\n      };\n    }\n  }\n}