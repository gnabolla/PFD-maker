import { PDSData, PDSValidationResult, PDSValidationError } from '@/models/pds';\nimport { logger } from '@/utils/logger';\nimport { format, parse, isValid } from 'date-fns';\n\nexport interface AutoFixResult {\n  correctedData: PDSData;\n  fixesApplied: AppliedFix[];\n  fixSummary: string;\n  unfixableErrors: PDSValidationError[];\n}\n\nexport interface AppliedFix {\n  field: string;\n  originalValue: any;\n  correctedValue: any;\n  fixType: string;\n  description: string;\n}\n\nexport class PDSAutoFixService {\n  /**\n   * Automatically fixes common PDS formatting errors\n   */\n  public static autoFixPDS(pdsData: PDSData, validationResult: PDSValidationResult): AutoFixResult {\n    const correctedData = JSON.parse(JSON.stringify(pdsData)) as PDSData;\n    const fixesApplied: AppliedFix[] = [];\n    const unfixableErrors: PDSValidationError[] = [];\n\n    logger.info('Starting auto-fix process', {\n      totalErrors: validationResult.errors.length,\n      totalWarnings: validationResult.warnings.length\n    });\n\n    // Process each validation error and attempt to fix\n    for (const error of validationResult.errors) {\n      try {\n        const fix = this.attemptFix(correctedData, error);\n        if (fix) {\n          fixesApplied.push(fix);\n          this.applyFix(correctedData, fix);\n        } else {\n          unfixableErrors.push(error);\n        }\n      } catch (fixError) {\n        logger.error('Auto-fix attempt failed', {\n          field: error.field,\n          error: fixError.message\n        });\n        unfixableErrors.push(error);\n      }\n    }\n\n    const fixSummary = this.generateFixSummary(fixesApplied, unfixableErrors);\n\n    logger.info('Auto-fix process completed', {\n      fixesApplied: fixesApplied.length,\n      unfixableErrors: unfixableErrors.length\n    });\n\n    return {\n      correctedData,\n      fixesApplied,\n      fixSummary,\n      unfixableErrors\n    };\n  }\n\n  /**\n   * Attempts to fix a specific validation error\n   */\n  private static attemptFix(data: PDSData, error: PDSValidationError): AppliedFix | null {\n    const fieldPath = error.field;\n    const currentValue = this.getNestedValue(data, fieldPath);\n\n    switch (error.code) {\n      case 'INVALID_DATE_FORMAT':\n        return this.fixDateFormat(fieldPath, currentValue, error);\n      \n      case 'REQUIRED_FIELD':\n        return this.fixRequiredField(fieldPath, currentValue, error);\n      \n      case 'ABBREVIATION_NOT_ALLOWED':\n        return this.fixAbbreviation(fieldPath, currentValue, error);\n      \n      case 'INVALID_NAME_FORMAT':\n        return this.fixNameFormat(fieldPath, currentValue, error);\n      \n      case 'INVALID_EMAIL_FORMAT':\n        return this.fixEmailFormat(fieldPath, currentValue, error);\n      \n      case 'INVALID_CIVIL_STATUS':\n        return this.fixCivilStatus(fieldPath, currentValue, error);\n      \n      case 'INVALID_SALARY_GRADE_FORMAT':\n        return this.fixSalaryGradeFormat(fieldPath, currentValue, error);\n      \n      case 'EMPTY_FIELD':\n        return this.fixEmptyField(fieldPath, currentValue, error);\n      \n      default:\n        return null;\n    }\n  }\n\n  /**\n   * Fixes date format errors (converts to MM/DD/YYYY)\n   */\n  private static fixDateFormat(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (!currentValue || typeof currentValue !== 'string') {\n      return null;\n    }\n\n    try {\n      // Try to parse various date formats\n      const dateFormats = [\n        'yyyy-MM-dd',\n        'dd/MM/yyyy',\n        'yyyy/MM/dd',\n        'MM-dd-yyyy',\n        'dd-MM-yyyy',\n        'yyyy.MM.dd',\n        'dd.MM.yyyy'\n      ];\n\n      let parsedDate: Date | null = null;\n      \n      for (const dateFormat of dateFormats) {\n        try {\n          const parsed = parse(currentValue, dateFormat, new Date());\n          if (isValid(parsed)) {\n            parsedDate = parsed;\n            break;\n          }\n        } catch {\n          continue;\n        }\n      }\n\n      // Try natural parsing as fallback\n      if (!parsedDate) {\n        parsedDate = new Date(currentValue);\n        if (!isValid(parsedDate)) {\n          return null;\n        }\n      }\n\n      // Format to MM/DD/YYYY\n      const correctedValue = format(parsedDate, 'MM/dd/yyyy');\n\n      return {\n        field: fieldPath,\n        originalValue: currentValue,\n        correctedValue,\n        fixType: 'DATE_FORMAT_CORRECTION',\n        description: `Converted date from \"${currentValue}\" to MM/DD/YYYY format`\n      };\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Fixes required field errors by adding N/A\n   */\n  private static fixRequiredField(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (currentValue !== undefined && currentValue !== null && currentValue !== '') {\n      return null;\n    }\n\n    // Only fix non-critical required fields with N/A\n    const nonCriticalFields = [\n      'nameExtension',\n      'civilStatusDetails',\n      'telephoneNumber',\n      'gsisId',\n      'pagibigId',\n      'philhealthId',\n      'sssId',\n      'tinId',\n      'agencyEmployeeId',\n      'dualCitizenship'\n    ];\n\n    const fieldName = fieldPath.split('.').pop();\n    if (nonCriticalFields.includes(fieldName || '')) {\n      return {\n        field: fieldPath,\n        originalValue: currentValue,\n        correctedValue: 'N/A',\n        fixType: 'REQUIRED_FIELD_NA',\n        description: `Added \"N/A\" to required field \"${fieldName}\"`\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Fixes abbreviation errors by expanding common abbreviations\n   */\n  private static fixAbbreviation(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (!currentValue || typeof currentValue !== 'string') {\n      return null;\n    }\n\n    const abbreviationMap: Record<string, string> = {\n      'CSC': 'Civil Service Commission',\n      'DILG': 'Department of the Interior and Local Government',\n      'DOH': 'Department of Health',\n      'DepEd': 'Department of Education',\n      'DOST': 'Department of Science and Technology',\n      'DBM': 'Department of Budget and Management',\n      'DSWD': 'Department of Social Welfare and Development',\n      'Univ': 'University',\n      'Inst': 'Institute',\n      'Dept': 'Department',\n      'Gov': 'Government',\n      'Nat\\'l': 'National',\n      'Reg\\'l': 'Regional',\n      'Phil': 'Philippine',\n      'Inc': 'Incorporated',\n      'Corp': 'Corporation',\n      'Co': 'Company',\n      'Ltd': 'Limited',\n      'LLC': 'Limited Liability Company'\n    };\n\n    let correctedValue = currentValue;\n    let hasChanges = false;\n\n    for (const [abbrev, expanded] of Object.entries(abbreviationMap)) {\n      const regex = new RegExp(`\\\\b${abbrev}\\\\b`, 'gi');\n      if (regex.test(correctedValue)) {\n        correctedValue = correctedValue.replace(regex, expanded);\n        hasChanges = true;\n      }\n    }\n\n    if (hasChanges) {\n      return {\n        field: fieldPath,\n        originalValue: currentValue,\n        correctedValue,\n        fixType: 'ABBREVIATION_EXPANSION',\n        description: `Expanded abbreviations in \"${currentValue}\" to full form`\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Fixes name format errors\n   */\n  private static fixNameFormat(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (!currentValue || typeof currentValue !== 'string') {\n      return null;\n    }\n\n    // Fix reference name format to \"FIRST NAME, MI, SURNAME\"\n    if (fieldPath.includes('references') && fieldPath.includes('name')) {\n      const nameParts = currentValue.split(/[,\\s]+/).filter(part => part.length > 0);\n      \n      if (nameParts.length >= 3) {\n        // Assume: [First] [Middle] [Last] or [First] [MI] [Last]\n        const firstName = nameParts[0].toUpperCase();\n        const middleInitial = nameParts[1].length === 1 ? nameParts[1].toUpperCase() + '.' : nameParts[1].charAt(0).toUpperCase() + '.';\n        const surname = nameParts.slice(2).join(' ').toUpperCase();\n        \n        const correctedValue = `${firstName}, ${middleInitial}, ${surname}`;\n        \n        return {\n          field: fieldPath,\n          originalValue: currentValue,\n          correctedValue,\n          fixType: 'NAME_FORMAT_CORRECTION',\n          description: `Formatted name to \"FIRST NAME, MI, SURNAME\" format`\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Fixes email format errors\n   */\n  private static fixEmailFormat(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (!currentValue || typeof currentValue !== 'string') {\n      return null;\n    }\n\n    // Basic email fixes\n    let correctedValue = currentValue.toLowerCase().trim();\n    \n    // Fix common domain typos\n    const domainFixes: Record<string, string> = {\n      'gmail.co': 'gmail.com',\n      'yahoo.co': 'yahoo.com',\n      'hotmail.co': 'hotmail.com',\n      'gmial.com': 'gmail.com',\n      'gmai.com': 'gmail.com',\n      'yahooo.com': 'yahoo.com'\n    };\n\n    for (const [typo, correct] of Object.entries(domainFixes)) {\n      if (correctedValue.includes(typo)) {\n        correctedValue = correctedValue.replace(typo, correct);\n        \n        return {\n          field: fieldPath,\n          originalValue: currentValue,\n          correctedValue,\n          fixType: 'EMAIL_FORMAT_CORRECTION',\n          description: `Fixed email domain typo: ${typo} â†’ ${correct}`\n        };\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Fixes civil status errors\n   */\n  private static fixCivilStatus(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (!currentValue || typeof currentValue !== 'string') {\n      return null;\n    }\n\n    const statusMap: Record<string, string> = {\n      'single': 'Single',\n      'married': 'Married',\n      'widowed': 'Widowed',\n      'separated': 'Separated',\n      'divorced': 'Others', // Philippines doesn't recognize divorce, map to Others\n      'unmarried': 'Single',\n      'wed': 'Married'\n    };\n\n    const normalizedValue = currentValue.toLowerCase().trim();\n    const correctedValue = statusMap[normalizedValue];\n\n    if (correctedValue) {\n      return {\n        field: fieldPath,\n        originalValue: currentValue,\n        correctedValue,\n        fixType: 'CIVIL_STATUS_CORRECTION',\n        description: `Standardized civil status to \"${correctedValue}\"`\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Fixes salary grade format errors\n   */\n  private static fixSalaryGradeFormat(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (!currentValue || typeof currentValue !== 'string') {\n      return null;\n    }\n\n    // Try to extract numbers and format as \"00-0\"\n    const matches = currentValue.match(/(\\d+)[\\s\\-_]*(\\d+)/);\n    if (matches) {\n      const grade = matches[1].padStart(2, '0');\n      const step = matches[2];\n      const correctedValue = `${grade}-${step}`;\n      \n      return {\n        field: fieldPath,\n        originalValue: currentValue,\n        correctedValue,\n        fixType: 'SALARY_GRADE_FORMAT_CORRECTION',\n        description: `Formatted salary grade to \"00-0\" format`\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Fixes empty field errors by adding N/A\n   */\n  private static fixEmptyField(fieldPath: string, currentValue: any, error: PDSValidationError): AppliedFix | null {\n    if (currentValue && currentValue.length > 0) {\n      return null;\n    }\n\n    // Add N/A to empty arrays in other information\n    if (fieldPath.includes('otherInformation')) {\n      return {\n        field: fieldPath,\n        originalValue: currentValue,\n        correctedValue: ['N/A'],\n        fixType: 'EMPTY_FIELD_NA',\n        description: `Added \"N/A\" to empty field`\n      };\n    }\n\n    return null;\n  }\n\n  /**\n   * Applies a fix to the data object\n   */\n  private static applyFix(data: PDSData, fix: AppliedFix): void {\n    this.setNestedValue(data, fix.field, fix.correctedValue);\n  }\n\n  /**\n   * Gets a nested value from an object using dot notation\n   */\n  private static getNestedValue(obj: any, path: string): any {\n    return path.split('.').reduce((current, key) => {\n      if (current === null || current === undefined) {\n        return undefined;\n      }\n      \n      // Handle array indices\n      const arrayMatch = key.match(/(.+)\\[(\\d+)\\]/);\n      if (arrayMatch) {\n        const [, arrayKey, index] = arrayMatch;\n        return current[arrayKey]?.[parseInt(index)];\n      }\n      \n      return current[key];\n    }, obj);\n  }\n\n  /**\n   * Sets a nested value in an object using dot notation\n   */\n  private static setNestedValue(obj: any, path: string, value: any): void {\n    const keys = path.split('.');\n    const lastKey = keys.pop()!;\n    \n    const target = keys.reduce((current, key) => {\n      // Handle array indices\n      const arrayMatch = key.match(/(.+)\\[(\\d+)\\]/);\n      if (arrayMatch) {\n        const [, arrayKey, index] = arrayMatch;\n        if (!current[arrayKey]) {\n          current[arrayKey] = [];\n        }\n        if (!current[arrayKey][parseInt(index)]) {\n          current[arrayKey][parseInt(index)] = {};\n        }\n        return current[arrayKey][parseInt(index)];\n      }\n      \n      if (!current[key]) {\n        current[key] = {};\n      }\n      return current[key];\n    }, obj);\n\n    // Handle array index in last key\n    const arrayMatch = lastKey.match(/(.+)\\[(\\d+)\\]/);\n    if (arrayMatch) {\n      const [, arrayKey, index] = arrayMatch;\n      if (!target[arrayKey]) {\n        target[arrayKey] = [];\n      }\n      target[arrayKey][parseInt(index)] = value;\n    } else {\n      target[lastKey] = value;\n    }\n  }\n\n  /**\n   * Generates a summary of applied fixes\n   */\n  private static generateFixSummary(fixes: AppliedFix[], unfixableErrors: PDSValidationError[]): string {\n    if (fixes.length === 0) {\n      return 'No automatic fixes could be applied.';\n    }\n\n    const fixTypeCount = fixes.reduce((acc, fix) => {\n      acc[fix.fixType] = (acc[fix.fixType] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n\n    const summaryParts = Object.entries(fixTypeCount).map(([type, count]) => {\n      switch (type) {\n        case 'DATE_FORMAT_CORRECTION':\n          return `${count} date format${count > 1 ? 's' : ''} corrected`;\n        case 'REQUIRED_FIELD_NA':\n          return `${count} required field${count > 1 ? 's' : ''} filled with N/A`;\n        case 'ABBREVIATION_EXPANSION':\n          return `${count} abbreviation${count > 1 ? 's' : ''} expanded`;\n        case 'NAME_FORMAT_CORRECTION':\n          return `${count} name format${count > 1 ? 's' : ''} standardized`;\n        case 'EMAIL_FORMAT_CORRECTION':\n          return `${count} email format${count > 1 ? 's' : ''} corrected`;\n        case 'CIVIL_STATUS_CORRECTION':\n          return `${count} civil status value${count > 1 ? 's' : ''} standardized`;\n        case 'SALARY_GRADE_FORMAT_CORRECTION':\n          return `${count} salary grade format${count > 1 ? 's' : ''} corrected`;\n        case 'EMPTY_FIELD_NA':\n          return `${count} empty field${count > 1 ? 's' : ''} filled with N/A`;\n        default:\n          return `${count} ${type.toLowerCase().replace(/_/g, ' ')}${count > 1 ? 's' : ''} applied`;\n      }\n    });\n\n    let summary = `Applied ${fixes.length} automatic fix${fixes.length > 1 ? 'es' : ''}: ${summaryParts.join(', ')}.`;\n    \n    if (unfixableErrors.length > 0) {\n      summary += ` ${unfixableErrors.length} error${unfixableErrors.length > 1 ? 's' : ''} require${unfixableErrors.length === 1 ? 's' : ''} manual attention.`;\n    }\n\n    return summary;\n  }\n}