import { Request, Response, NextFunction } from 'express';\nimport { FileImportService } from '@/services/fileImport';\nimport { PDSValidationService } from '@/services/pdsValidation';\nimport { asyncHandler, AppError } from '@/middleware/errorHandler';\nimport { logger } from '@/utils/logger';\nimport * as fs from 'fs';\nimport * as path from 'path';\n\nexport class ImportController {\n  /**\n   * Imports PDS file and extracts data\n   */\n  public static importPDSFile = asyncHandler(async (req: Request, res: Response) => {\n    const requestId = req.headers['x-request-id'] as string;\n    \n    if (!req.file) {\n      throw new AppError('No file uploaded', 400, 'NO_FILE_UPLOADED');\n    }\n\n    logger.info('PDS file import request received', {\n      requestId,\n      filename: req.file.filename,\n      originalName: req.file.originalname,\n      mimetype: req.file.mimetype,\n      size: req.file.size\n    });\n\n    try {\n      // Process the uploaded file\n      const importResult = await FileImportService.importPDSFile(req.file);\n      \n      // Validate the extracted data if it contains enough information\n      let validationResult = null;\n      if (importResult.extractedData && Object.keys(importResult.extractedData).length > 0) {\n        try {\n          // Only validate if we have personal information (minimum requirement)\n          if (importResult.extractedData.personalInformation) {\n            validationResult = PDSValidationService.validatePDS(importResult.extractedData as any);\n          }\n        } catch (validationError) {\n          logger.warn('Validation of imported data failed', {\n            requestId,\n            error: validationError.message\n          });\n        }\n      }\n\n      // Clean up the uploaded file after processing\n      try {\n        if (fs.existsSync(req.file.path)) {\n          fs.unlinkSync(req.file.path);\n        }\n      } catch (cleanupError) {\n        logger.warn('Failed to clean up uploaded file', {\n          requestId,\n          filePath: req.file.path,\n          error: cleanupError.message\n        });\n      }\n\n      logger.info('PDS file import completed', {\n        requestId,\n        filename: importResult.filename,\n        processingErrorsCount: importResult.processingErrors.length,\n        extractedFieldsCount: Object.keys(importResult.extractedData).length,\n        hasValidation: validationResult !== null\n      });\n\n      res.json({\n        success: true,\n        data: {\n          import: {\n            filename: importResult.filename,\n            originalName: importResult.originalName,\n            mimetype: importResult.mimetype,\n            size: importResult.size,\n            processingErrors: importResult.processingErrors,\n            extractedFieldsCount: Object.keys(importResult.extractedData).length\n          },\n          extractedData: importResult.extractedData,\n          validation: validationResult ? {\n            isValid: validationResult.isValid,\n            errorCount: validationResult.errors.length,\n            warningCount: validationResult.warnings.length,\n            errors: validationResult.errors.slice(0, 10), // Limit to first 10 errors for response size\n            warnings: validationResult.warnings.slice(0, 5) // Limit to first 5 warnings\n          } : null,\n          recommendations: {\n            needsManualReview: importResult.processingErrors.length > 0,\n            hasValidationErrors: validationResult ? validationResult.errors.length > 0 : false,\n            suggestedActions: this.generateRecommendations(importResult, validationResult)\n          },\n          processedAt: new Date().toISOString()\n        }\n      });\n    } catch (error) {\n      // Clean up the uploaded file in case of error\n      try {\n        if (req.file && fs.existsSync(req.file.path)) {\n          fs.unlinkSync(req.file.path);\n        }\n      } catch (cleanupError) {\n        logger.warn('Failed to clean up uploaded file after error', {\n          requestId,\n          filePath: req.file?.path,\n          error: cleanupError.message\n        });\n      }\n\n      logger.error('PDS file import failed', {\n        requestId,\n        filename: req.file.filename,\n        error: error.message,\n        stack: error.stack\n      });\n      \n      if (error instanceof AppError) {\n        throw error;\n      }\n      \n      throw new AppError('File import failed', 500, 'IMPORT_ERROR');\n    }\n  });\n\n  /**\n   * Gets supported file formats and their requirements\n   */\n  public static getSupportedFormats = asyncHandler(async (req: Request, res: Response) => {\n    res.json({\n      success: true,\n      data: {\n        supportedFormats: [\n          {\n            format: 'Excel',\n            mimetype: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n            extension: '.xlsx',\n            description: 'Microsoft Excel workbook format',\n            requirements: [\n              'First worksheet will be processed',\n              'Data should be in standard PDS Excel template format',\n              'Column headers should match PDS field names'\n            ]\n          },\n          {\n            format: 'Word',\n            mimetype: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n            extension: '.docx',\n            description: 'Microsoft Word document format',\n            requirements: [\n              'Text-based content extraction',\n              'Standard PDS form layout preferred',\n              'Clear field labels and values'\n            ]\n          },\n          {\n            format: 'PDF',\n            mimetype: 'application/pdf',\n            extension: '.pdf',\n            description: 'Portable Document Format',\n            requirements: [\n              'Text-based PDF (not scanned images)',\n              'Clear text formatting',\n              'Standard PDS layout preferred'\n            ]\n          }\n        ],\n        limitations: {\n          maxFileSize: '10MB',\n          textExtractionOnly: 'Scanned images or handwritten content cannot be processed',\n          accuracy: 'Extraction accuracy depends on file format and structure',\n          manualReview: 'Imported data should always be reviewed and validated'\n        },\n        bestPractices: [\n          'Use the official PDS Excel template for best results',\n          'Ensure consistent formatting and field labels',\n          'Review and validate all imported data before submission',\n          'Keep original files as backup'\n        ]\n      }\n    });\n  });\n\n  /**\n   * Validates uploaded file before processing\n   */\n  public static validateUploadedFile = asyncHandler(async (req: Request, res: Response) => {\n    if (!req.file) {\n      throw new AppError('No file uploaded', 400, 'NO_FILE_UPLOADED');\n    }\n\n    const requestId = req.headers['x-request-id'] as string;\n    \n    logger.info('File validation request received', {\n      requestId,\n      filename: req.file.filename,\n      mimetype: req.file.mimetype,\n      size: req.file.size\n    });\n\n    // Validate file type\n    const allowedTypes = [\n      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',\n      'application/pdf'\n    ];\n\n    const validationType = allowedTypes.includes(req.file.mimetype);\n    const validationSize = req.file.size <= 10 * 1024 * 1024; // 10MB\n    const validationExtension = this.validateFileExtension(req.file.originalname, req.file.mimetype);\n\n    // Clean up the uploaded file\n    try {\n      if (fs.existsSync(req.file.path)) {\n        fs.unlinkSync(req.file.path);\n      }\n    } catch (cleanupError) {\n      logger.warn('Failed to clean up validation file', {\n        requestId,\n        error: cleanupError.message\n      });\n    }\n\n    const isValid = validationType && validationSize && validationExtension;\n\n    res.json({\n      success: true,\n      data: {\n        filename: req.file.originalname,\n        isValid,\n        validations: {\n          fileType: {\n            valid: validationType,\n            detected: req.file.mimetype,\n            message: validationType ? 'Supported file type' : 'Unsupported file type'\n          },\n          fileSize: {\n            valid: validationSize,\n            size: req.file.size,\n            sizeFormatted: this.formatFileSize(req.file.size),\n            maxSize: '10MB',\n            message: validationSize ? 'File size within limits' : 'File size exceeds 10MB limit'\n          },\n          fileExtension: {\n            valid: validationExtension,\n            extension: path.extname(req.file.originalname),\n            message: validationExtension ? 'File extension matches content type' : 'File extension does not match content type'\n          }\n        },\n        recommendations: isValid ? [\n          'File is ready for import',\n          'Review extracted data after import',\n          'Validate all fields before submission'\n        ] : [\n          'Please use a supported file format (.xlsx, .docx, .pdf)',\n          'Ensure file size is under 10MB',\n          'Check that file extension matches content'\n        ],\n        validatedAt: new Date().toISOString()\n      }\n    });\n  });\n\n  /**\n   * Generates recommendations based on import results\n   */\n  private static generateRecommendations(importResult: any, validationResult: any): string[] {\n    const recommendations: string[] = [];\n\n    if (importResult.processingErrors.length > 0) {\n      recommendations.push('Review processing errors and manually verify affected fields');\n    }\n\n    if (validationResult && validationResult.errors.length > 0) {\n      recommendations.push('Address validation errors before submitting PDS');\n      \n      // Check for common error types\n      const dateErrors = validationResult.errors.filter((e: any) => e.code === 'INVALID_DATE_FORMAT');\n      if (dateErrors.length > 0) {\n        recommendations.push('Fix date formats to MM/DD/YYYY');\n      }\n      \n      const requiredErrors = validationResult.errors.filter((e: any) => e.code === 'REQUIRED_FIELD');\n      if (requiredErrors.length > 0) {\n        recommendations.push('Fill in all required fields or use \"N/A\" where applicable');\n      }\n      \n      const abbreviationErrors = validationResult.errors.filter((e: any) => e.code === 'ABBREVIATION_NOT_ALLOWED');\n      if (abbreviationErrors.length > 0) {\n        recommendations.push('Replace abbreviations with full names');\n      }\n    }\n\n    if (Object.keys(importResult.extractedData).length === 0) {\n      recommendations.push('No data could be extracted - consider using the official PDS Excel template');\n    } else if (Object.keys(importResult.extractedData).length < 3) {\n      recommendations.push('Limited data extracted - manually review and complete missing sections');\n    }\n\n    if (recommendations.length === 0) {\n      recommendations.push('Data imported successfully - review all fields before final submission');\n    }\n\n    return recommendations;\n  }\n\n  /**\n   * Validates file extension matches content type\n   */\n  private static validateFileExtension(filename: string, mimetype: string): boolean {\n    const extension = path.extname(filename).toLowerCase();\n    \n    const mimetypeExtensionMap: Record<string, string[]> = {\n      'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': ['.xlsx'],\n      'application/vnd.openxmlformats-officedocument.wordprocessingml.document': ['.docx'],\n      'application/pdf': ['.pdf']\n    };\n\n    const validExtensions = mimetypeExtensionMap[mimetype] || [];\n    return validExtensions.includes(extension);\n  }\n\n  /**\n   * Formats file size for human readability\n   */\n  private static formatFileSize(bytes: number): string {\n    if (bytes === 0) return '0 Bytes';\n    \n    const k = 1024;\n    const sizes = ['Bytes', 'KB', 'MB', 'GB'];\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    \n    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];\n  }\n}