import { Request, Response, NextFunction } from 'express';\nimport { PDSValidationService } from '@/services/pdsValidation';\nimport { PDSData } from '@/models/pds';\nimport { asyncHandler, AppError } from '@/middleware/errorHandler';\nimport { logger } from '@/utils/logger';\n\nexport class ValidationController {\n  /**\n   * Validates PDS data according to CSC requirements\n   */\n  public static validatePDS = asyncHandler(async (req: Request, res: Response) => {\n    const requestId = req.headers['x-request-id'] as string;\n    \n    logger.info('PDS validation request received', {\n      requestId,\n      dataSize: JSON.stringify(req.body).length\n    });\n\n    // Validate request body\n    if (!req.body || Object.keys(req.body).length === 0) {\n      throw new AppError('PDS data is required', 400, 'MISSING_PDS_DATA');\n    }\n\n    try {\n      // Cast request body to PDSData type\n      const pdsData = req.body as PDSData;\n      \n      // Validate PDS data\n      const validationResult = PDSValidationService.validatePDS(pdsData);\n      \n      logger.info('PDS validation completed', {\n        requestId,\n        isValid: validationResult.isValid,\n        errorCount: validationResult.errors.length,\n        warningCount: validationResult.warnings.length\n      });\n\n      // Return validation results\n      res.json({\n        success: true,\n        data: {\n          isValid: validationResult.isValid,\n          summary: {\n            totalErrors: validationResult.errors.length,\n            totalWarnings: validationResult.warnings.length,\n            criticalErrors: validationResult.errors.filter(e => e.severity === 'error').length,\n            fieldErrors: validationResult.errors.reduce((acc, error) => {\n              const field = error.field.split('.')[0];\n              acc[field] = (acc[field] || 0) + 1;\n              return acc;\n            }, {} as Record<string, number>)\n          },\n          errors: validationResult.errors,\n          warnings: validationResult.warnings,\n          validatedAt: new Date().toISOString()\n        }\n      });\n    } catch (error) {\n      logger.error('PDS validation failed', {\n        requestId,\n        error: error.message,\n        stack: error.stack\n      });\n      \n      if (error instanceof AppError) {\n        throw error;\n      }\n      \n      throw new AppError('PDS validation failed', 500, 'VALIDATION_ERROR');\n    }\n  });\n\n  /**\n   * Auto-fixes common PDS formatting errors\n   */\n  public static autoFixPDS = asyncHandler(async (req: Request, res: Response) => {\n    const requestId = req.headers['x-request-id'] as string;\n    \n    logger.info('PDS auto-fix request received', {\n      requestId,\n      dataSize: JSON.stringify(req.body).length\n    });\n\n    // Validate request body\n    if (!req.body || Object.keys(req.body).length === 0) {\n      throw new AppError('PDS data is required', 400, 'MISSING_PDS_DATA');\n    }\n\n    try {\n      // Cast request body to PDSData type\n      const pdsData = req.body as PDSData;\n      \n      // First, validate to identify errors\n      const validationResult = PDSValidationService.validatePDS(pdsData);\n      \n      // Apply auto-fixes (will implement auto-fix service next)\n      const autoFixService = await import('@/services/pdsAutoFix');\n      const fixResult = autoFixService.PDSAutoFixService.autoFixPDS(pdsData, validationResult);\n      \n      // Validate the fixed data\n      const revalidationResult = PDSValidationService.validatePDS(fixResult.correctedData);\n      \n      logger.info('PDS auto-fix completed', {\n        requestId,\n        originalErrors: validationResult.errors.length,\n        fixedErrors: fixResult.fixesApplied.length,\n        remainingErrors: revalidationResult.errors.length\n      });\n\n      res.json({\n        success: true,\n        data: {\n          original: {\n            isValid: validationResult.isValid,\n            errorCount: validationResult.errors.length,\n            warningCount: validationResult.warnings.length\n          },\n          corrected: {\n            isValid: revalidationResult.isValid,\n            errorCount: revalidationResult.errors.length,\n            warningCount: revalidationResult.warnings.length,\n            data: fixResult.correctedData\n          },\n          fixes: {\n            applied: fixResult.fixesApplied,\n            count: fixResult.fixesApplied.length,\n            description: fixResult.fixSummary\n          },\n          improvement: {\n            errorsFixed: validationResult.errors.length - revalidationResult.errors.length,\n            warningsFixed: validationResult.warnings.length - revalidationResult.warnings.length,\n            percentageImprovement: validationResult.errors.length > 0 \n              ? Math.round(((validationResult.errors.length - revalidationResult.errors.length) / validationResult.errors.length) * 100)\n              : 0\n          },\n          processedAt: new Date().toISOString()\n        }\n      });\n    } catch (error) {\n      logger.error('PDS auto-fix failed', {\n        requestId,\n        error: error.message,\n        stack: error.stack\n      });\n      \n      if (error instanceof AppError) {\n        throw error;\n      }\n      \n      throw new AppError('PDS auto-fix failed', 500, 'AUTO_FIX_ERROR');\n    }\n  });\n\n  /**\n   * Validates specific PDS field\n   */\n  public static validateField = asyncHandler(async (req: Request, res: Response) => {\n    const { fieldPath, value } = req.body;\n    const requestId = req.headers['x-request-id'] as string;\n    \n    if (!fieldPath || value === undefined) {\n      throw new AppError('Field path and value are required', 400, 'MISSING_FIELD_DATA');\n    }\n    \n    logger.info('Field validation request received', {\n      requestId,\n      fieldPath,\n      valueType: typeof value\n    });\n\n    try {\n      // Use validation service to validate specific field\n      const fieldValidation = PDSValidationService.validateField(fieldPath, value);\n      \n      res.json({\n        success: true,\n        data: {\n          field: fieldPath,\n          value,\n          isValid: fieldValidation.isValid,\n          errors: fieldValidation.errors,\n          suggestions: fieldValidation.suggestions,\n          validatedAt: new Date().toISOString()\n        }\n      });\n    } catch (error) {\n      logger.error('Field validation failed', {\n        requestId,\n        fieldPath,\n        error: error.message\n      });\n      \n      throw new AppError('Field validation failed', 500, 'FIELD_VALIDATION_ERROR');\n    }\n  });\n}